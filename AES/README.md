AES працює з блоками даних фіксованого розміру, який може бути 128, 192 або 256 біт. Ключ шифрування також має фіксований розмір, який залежить від розміру блоку. Так, для AES-128 використовується ключ розміром 128 біт, для AES-192 - 192 біта, а для AES-256 - 256 біт.

Основний принцип роботи AES полягає в послідовному застосуванні декількох раундів перетворень до блоку даних. Кількість раундів залежить від розміру ключа: 10 раундів для AES-128, 12 раундів для AES-192 та 14 раундів для AES-256.

Кожен раунд складається з п'яти основних операцій:
<ul>
<li>SubBytes: Кожен байт в стані замінюється на відповідний байт за допомогою S-Box, який є нелінійною таблицею заміни.</li>
<li>ShiftRows: Байти у стані переставляються по рядках.</li>
<li>MixColumns: Колонки стану перемішуються за допомогою матричних операцій над байтами.</li>
<li>AddRoundKey: Раундовий ключ додається до стану даних за допомогою операції побітового XOR.</li>
<li>Повторення першого раунду для додаткових раундів, але без операції MixColumns у останньому раунді.</li>
</ul>
<p>Цей процес повторюється для встановленої кількості раундів, після чого отримується зашифрований блок даних.</p>

<p>Далі розглянемо як працює код.</p>

Перш за все, у файлі `aes.py` визначено деякі таблиці S_BOX і INV_S_BOX, які використовуються для заміни байтів у матриці підстановки.

У функції `substitute_bytes(s)` здійснюється заміна кожного байту у матриці `s` за допомогою S_BOX. Функція проходить через всі елементи матриці `s` і замінює значення кожного байту за його відповідним значенням у S_BOX.

Функція `inv_substitute_bytes(s)` виконує обернену заміну байтів у матриці `s` за допомогою INV_S_BOX. Це замінює значення кожного байту у матриці `s` на його відповідне значення у INV_S_BOX.

Функція `shift_rows(s)` виконує зсув рядків у матриці `s`. У цій функції перший рядок залишається без змін, другий рядок зсувається вліво на 1 байт, третій рядок зсувається вліво на 2 байти, четвертий рядок зсувається вліво на 3 байти.

Функція `inv_shift_rows(s)` виконує зворотній зсув рядків у матриці `s`. У цій функції перший рядок залишається без змін, другий рядок зсувається вправо на 1 байт, третій рядок зсувається вправо на 2 байти, четвертий рядок зсувається вправо на 3 байти.

Код у файлі `main.py` шифрує та розшифровує повідомлення за допомогою AES. В першому рядку коду генерується випадковий ключ (`key`) та ініціалізаційний вектор (`iv`) за допомогою функції `os.urandom`. Текст, який має бути зашифрованим, зберігається у змінній `plaintext`. Використовується режим шифрування лічильника, тому ми визначаємо функцію `encrypt(plaintext, key, iv)`, яка виконує шифрування тексту.

Функція `encrypt` розбиває текст на блоки за допомогою функції `split_blocks`, а потім для кожного блоку виконує шифрування за допомогою функції `encrypt_block`. Шифрування блоку включає додавання згенерованого IV до блоку і застосування функції AES до отриманого результату. Зашифровані блоки зберігаються у списку `cipher_blocks`.

Функція `encrypt_block(block, key, iv_counter)` виконує шифрування одного блоку. Спочатку блок XOR-ується з IV та лічильником, а потім застосовується функція AES до отриманого результату.

Після шифрування ми можемо розшифрувати зашифрований текст. Функція `decrypt(ciphertext, key, iv)` виконує розшифрування тексту.

Функція `decrypt` розбиває зашифрований текст на блоки та виконує розшифрування для кожного блоку за допомогою функції `decrypt_block`. Розшифровані блоки зберігаються у списку `plain_blocks`.

Функція `decrypt_block(block, key, iv_counter)` виконує розшифрування одного блоку. Спочатку застосовується функція AES до блоку, а потім результат XOR-ується з IV та лічильником.

У нашому випадку, ми шифруємо та розшифровуємо повідомлення, використовуючи той самий ключ та IV. Результат шифрування виводиться на екран разом з розшифрованим текстом для порівняння.
